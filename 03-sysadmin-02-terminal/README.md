# Домашнее задание к занятию "3.2. Работа в терминале, лекция 2"

1. Какого типа команда `cd`? Попробуйте объяснить, почему она именно такого типа; опишите ход своих мыслей, если считаете что она могла бы быть другого типа.
1. Какая альтернатива без pipe команде `grep <some_string> <some_file> | wc -l`? `man grep` поможет в ответе на этот вопрос. Ознакомьтесь с [документом](http://www.smallo.ruhr.de/award.html) о других подобных некорректных вариантах использования pipe.
1. Какой процесс с PID `1` является родителем для всех процессов в вашей виртуальной машине Ubuntu 20.04?
1. Как будет выглядеть команда, которая перенаправит вывод stderr `ls` на другую сессию терминала?
1. Получится ли одновременно передать команде файл на stdin и вывести ее stdout в другой файл? Приведите работающий пример.
1. Получится ли вывести находясь в графическом режиме данные из PTY в какой-либо из эмуляторов TTY? Сможете ли вы наблюдать выводимые данные?
1. Выполните команду `bash 5>&1`. К чему она приведет? Что будет, если вы выполните `echo netology > /proc/$$/fd/5`? Почему так происходит?
1. Получится ли в качестве входного потока для pipe использовать только stderr команды, не потеряв при этом отображение stdout на pty? Напоминаем: по умолчанию через pipe передается только stdout команды слева от `|` на stdin команды справа.
Это можно сделать, поменяв стандартные потоки местами через промежуточный новый дескриптор, который вы научились создавать в предыдущем вопросе.
1. Что выведет команда `cat /proc/$$/environ`? Как еще можно получить аналогичный по содержанию вывод?
1. Используя `man`, опишите что доступно по адресам `/proc/<PID>/cmdline`, `/proc/<PID>/exe`.
1. Узнайте, какую наиболее старшую версию набора инструкций SSE поддерживает ваш процессор с помощью `/proc/cpuinfo`.
1. При открытии нового окна терминала и `vagrant ssh` создается новая сессия и выделяется pty. Это можно подтвердить командой `tty`, которая упоминалась в лекции 3.2. Однако:

    ```bash
	vagrant@netology1:~$ ssh localhost 'tty'
	not a tty
    ```

	Почитайте, почему так происходит, и как изменить поведение.
1. Бывает, что есть необходимость переместить запущенный процесс из одной сессии в другую. Попробуйте сделать это, воспользовавшись `reptyr`. Например, так можно перенести в `screen` процесс, который вы запустили по ошибке в обычной SSH-сессии.
1. `sudo echo string > /root/new_file` не даст выполнить перенаправление под обычным пользователем, так как перенаправлением занимается процесс shell'а, который запущен без `sudo` под вашим пользователем. Для решения данной проблемы можно использовать конструкцию `echo string | sudo tee /root/new_file`. Узнайте что делает команда `tee` и почему в отличие от `sudo echo` команда с `sudo tee` будет работать.

## Решение

1. Команда `cd` встроенная в shell, так как `type cd` возвращает `cd is a shell builtin`, с другой стороны команда `which cd` возвращает пусто, что означает это не самостоятельный исполнимый файл или скрипт, найденный в каталогах указанный переменной PATH. Команда встроенная в shell поскольку эта команда - одна из его функций и за ее пределами не имеет смысла. 
2. Для подсчета количества строк совпадений можно воспользоваться аргументом `-с` команды grep, тогда команду `grep <some_string> <some_file> | wc -l` можно записать так: `grep -c <some_string> <some_file>`.
3. Процессом с PID 1 в Linux является программа инициализации для Ubuntu 20.04 это будет systemd, можно убедиться в этом командой `ps -p 1`.
4. Команда перенаправления вывода stderr `ls` на другую сессию терминала будет выглядеть примерно приблизительно так: `ls dir123 2> /dev/pts/1`, при условии, что другая сессия терминала назначена устройству `/dev/pts/1` и в случае если каталог `dir123` не существует мы увидим ошибку на указанном терминале.
5. Это возможно, например, так: `cat < list.txt > out.txt` или `cat > out.txt < list.txt`, где `list.txt` - входной файл, а `out.txt` - выходной файл.
6. Можно вывести данные из графического эмулятора терминала работающего с PTY в эмулятор TTY командой перенаправления, пример: `ls -l > /dev/tty3`. Чтобы наблюдать вывод, нужно было переключиться с помощью Ctrl+Alt+F3 и авторизоваться.
7. Команда `bash 5>&1` запускает новый экземпляр bash перенаправляя файловый дескриптор 5 на stdout, а так как данный дескриптор 5 не существует, он создается. Команда `echo netology > /proc/$$/fd/5` выводит сообщение `netology` в текущем экземпляре bash, так как файл `/proc/$$/fd/5` был создан в момент перенаправления и он указывает на /dev/pts/X, где X номер нашего текущего псевдо-терминала.
8. Можно передать stderr через pipe если использовать следующую конструкцию:  
`command_1 3>&1 1>&2 2>&3 3>&- | command_2`. В данной конструкции сначала создается временный дескриптор 3, который, так же как и дескриптор 1, связан с stdout (`3>&1`), далее мы перенаправляем stdout на stderr (`1>&2`), после чего мы перенаправляем stderr на stdout посредством временного дескриптора 3 (`2>&3`) и, опционально, закрываем дескриптор 3 (`3>&-`) за ненадобностью. Примером такой команды будет:  
`find / -maxdepth 2 -name 'var' 3>&1 1>&2 2>&3 3>&- | wc -l`. 
9. Команда `cat /proc/$$/environ` выводит переменные окружения текущего shell процесса, с которыми он был запущен. Другим способом вывести примерно тоже можно например командой: `ps e $$ | grep $$`, но придется еще дополнительно парсить.
10. `/proc/[pid]/cmdline` - содержит полную команду процесса с которой она была запущена  
  `/proc/[pid]/exe` - содержит ссылку на исполняемый файл файловой системы запущенного процесса, можно прочесть, например, командой: `readlink /proc/$$/exe`, которая возвращает `/usr/bin/bash`.
11. ```bash
    wp-yandex@deb-safe:~$ cat /proc/cpuinfo | grep flags | head -n 1
    flags		: fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 
    clflush mmx fxsr sse sse2 htsyscall nx pdpe1gb rdtscp lm constant_tsc rep_good nopl 
    xtopology nonstop_tsc cpuid tsc_known_freq pni pclmulqdq ssse3 fma cx16 pcid sse4_1 
    sse4_2 x2apic movbe popcnt tsc_deadline_timer aes xsave avx f16c rdrand hypervisor 
    lahf_lm abm 3dnowprefetch cpuid_fault invpcid_single ssbd ibrs ibpb stibp 
    ibrs_enhanced fsgsbase bmi1 avx2 smep bmi2 erms invpcid avx512f avx512dq rdseed adx 
    smap avx512ifma clflushopt clwb avx512cd sha_ni avx512bw avx512vl xsaveopt xsavec 
    xgetbv1 arat avx512vbmi umip pku ospke avx512_vbmi2 gfni vaes vpclmulqdq avx512_vnni 
    avx512_bitalg avx512_vpopcntdq md_clear arch_capabilities
    ```
    Из вывода данной команды можно видеть, что тут самая старшая инструкция набора команд sse: sse4_2. 
12. Команда `ssh localhost 'tty'` исполняется в режиме выполнения одиночной команды и в данном режиме, видимо, не назначается pty. Мне помог флаг `-t` для принудительного назначения. Итоговая команда: `ssh -t localhost 'tty'`.   
13. Для того чтобы переместить запущенный процесс к примеру внутрь screen, нужно выполнить следующие команды:  
    1. Переместить процесс в Suspended нажатием Ctrl+Z
    2. Переместить процесс в фоновый режим командой `bg`
    3. Изолировать процесс командой `disown <имя_запущенного_процесса>`
    4. Открыть новый экземпляр screen, например, командой: `screen -S test`
    5. Воспользоваться командой `reptyr $(pgrep <имя_запущенного_процесса>)` для открытия процесса.
14. Команда `tee` берет текст из stdin и записывает его в указанный файл. Команда `echo string | sudo tee /root/new_file` будет работать так как мы запускаем tee с правами суперпользователя, которая берет строку из stdin посредством pipe и без перенаправлений записывает в указанный файл.  